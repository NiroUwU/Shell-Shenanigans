#!/bin/bash
# Paths to directories:
PATH_cache=~/.cache/aliasrc
PATH_backup="$PATH_cache/backup"
PATH_programs=~/Programs

# Paths to files:
PATH_aliasrc=~/aliasrc
PATH_alias_list=~/alias_list

# Colours:
COL_reset="\e[0m"
COL_error="\e[31"
COL_warning="\e[33m"



# Check if cache path is valid:
if [[ ! -d $PATH_cache ]]; then
	mkdir $PATH_cache
fi
if [[ ! -d $PATH_backup ]]; then
	mkdir $PATH_backup
fi


# Check id alias source file is valid:
if [[ ! -f $PATH_alias_list ]]; then
	echo -e "#!/bin/bash\n# This file is autogenerated by your aliasrc!\n# Syntax:\n# cmd [ALIAS] [EXECUTE THIS] [DESCRIPTION]\n# pgm [ALIAS] [PATH TO EXECUTABLE] [DESCRIPTION] [optional: CUSTOMPATH (if left empty defaults to programs directory)]" > "$PATH_alias_list" && echo -e "Generated $PATH_alias_list! Read it for further information :)"
fi


# Functions to add aliases:
function cmd() {
	local alias_name="$1"
	local alias_exec="$2"
	local alias_desc="$3"

	# Create cache:
	echo -e "#!/bin/bash\n#NOTE: This files is autogenerated by your aliasrc!\nalias_name='$alias_name'\nalias_exec='$alias_exec'\nalias_desc='$alias_desc'" > "$PATH_cache"/"$alias_name".alias
	# Create alias for shell session:
	alias "$alias_name"="$alias_exec"
}
function pgm() {
	local PATH_full=$2

	# Custom path if $4 provided (defaults to $PATH_programs otherwise)
	local custompath=$4
	if [[ ${#custompath} -gt 0 ]]; then
		PATH_full=$custompath/$PATH_full
	else
		PATH_full=$PATH_programs/$PATH_full
	fi

	# Check if executable is valid:
	if [[ ! -f "$PATH_full" ]]; then
		echo -e "Error loading alias for â€™$1': executable at '$PATH_full' could not be located!"
		return
	fi
	
	# Add alias:
	cmd "$1" "$PATH_full" "$3"
}
# Load user aliases:
source "$PATH_alias_list"


# Aliasrc help commands:
function aliashelp() {
	# Get info from an alias file:
	function displayInfo() {
		local file="$1"

		# Check if alias cache file exists:
		if [[ ! -f $file ]]; then
			echo -e "Alias not found at '$file'"
			return
		fi

		# Source alias information:
		local alias_name=""
		local alias_exec=""
		local alias_desc=""

		source "$file"
		echo -e "Alias:        $alias_name\nDescription:  $alias_desc\nExecution:    $alias_exec"
	}

	local this=$1
	local operation=""

	if [[ ${#this} -gt 0 ]]; then
		operation="request_specific"
	else
		operation="display_all"
	fi

	# Execute operation:
	case "$operation" in
		display_all)
			local all_files=("$PATH_cache"/*.alias)
			for file in "${all_files[@]}"; do
				displayInfo "$file" && printf "\n"
			done
			echo -e "Aliashelp files are generated automatically in '$PATH_cache'."
			;;

		request_specific)
			local file="$PATH_cache/$this.alias"
			displayInfo "$file"
			;;

	esac
}

function aliasrc_update() {
	local consent=1
	function askForConsent() {
		read response
		if [[ ! $response == "y" && ! $response == "Y" ]]; then
			echo -e "Aborting."
			consent=0
			return
		fi
	}
	# Aliasrc source:
	local repository="NiroUwU/Shell-Shenanigans/main/aliasrc"
	local update_url="https://raw.githubusercontent.com/$repository"

	local NEW=$(curl $update_url)        || return
	local OLD=$(curl file:$PATH_aliasrc) || return
	
	# No differences found, return:
	if [[ "$NEW" == "$OLD" ]]; then
		echo -e "Your aliasrc is up-to date! Quitting updater. :)"
		return
	fi

	# Weird stuff going on with curl, asking user:
	if [[ ${#NEW} -lt ${#OLD}/3 ]]; then
		echo -e "\n>>> Start of fetched data:\n\n$NEW\n\n>>> End of fetched data\n"
		printf "WARNING: Fetched possibly corrupted or wrong file! Continue anyways? [y/N] " && askForConsent
	fi
	if [[ ! $consent == 1 ]]; then return; fi
	

	# Differences found, asking to update:
	printf "A new version was found, do you wish to update? [Y/n] " && askForConsent
	if [[ ! $consent == 1 ]]; then return; fi

	# Backup current aliasrc:
	local backup_time=$(date +%Y-%m-%d_%H:%M:%S)
	local backup_name="$PATH_backup/aliasrc.backupfrom_$backup_time"

	(echo -e "$OLD" > "$backup_name" && echo -e "Backed up current aliasrc to '$backup_name'.") || printf "WARNING: Backup failed, do you wish to proceed anyways? [y/N] " && askForConsent
	if [[ ! $consent == 1 ]]; then return; fi
	
	(echo "$NEW" > $PATH_aliasrc) && (echo "Update complete. (Re)source aliasrc or restart session to apply new changes.")
}

# Add aliasrc commands:
cmd "aliashelp" aliashelp "Displays help information about added aliases."
cmd "clearaliascache" "rm $PATH_cache/*.alias && rm $PATH_backup/*.backup*" "Clears cached alias files in '$PATH_cache'."
cmd "aliasrc_update" aliasrc_update "Updates aliasrc, if new version is available."
